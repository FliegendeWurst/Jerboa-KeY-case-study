package $$BRIDGE_PACKAGE;
/**
$$MODELER_COMMENT
 */


import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.lang.reflect.InvocationTargetException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.StringTokenizer;
import java.util.UUID;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;

import fr.up.xlim.sic.ig.jerboa.trigger.tools.JerboaMonitorInfo;
import fr.up.xlim.sic.ig.jerboa.viewer.GMapViewer;
import fr.up.xlim.sic.ig.jerboa.viewer.camera.Camera;
import fr.up.xlim.sic.ig.jerboa.viewer.tools.GMapViewerBridge;
import fr.up.xlim.sic.ig.jerboa.viewer.tools.GMapViewerColor;
import fr.up.xlim.sic.ig.jerboa.viewer.tools.GMapViewerPoint;
import fr.up.xlim.sic.ig.jerboa.viewer.tools.GMapViewerTuple;
import fr.up.xlim.sic.ig.jerboa.viewer.tools.JerboaMonitorInfoBridgeSerializerMonitor;
import up.jerboa.core.JerboaDart;
import up.jerboa.core.JerboaEmbeddingInfo;
import up.jerboa.core.JerboaGMap;
import up.jerboa.core.JerboaGMapArray;
import up.jerboa.core.JerboaModeler;
import up.jerboa.core.JerboaOrbit;
import up.jerboa.core.util.JerboaGMapDuplicateFactory;
import up.jerboa.core.util.Pair;
import up.jerboa.exception.JerboaException;
import up.jerboa.exception.JerboaGMapDuplicateException;
import up.jerboa.exception.JerboaNoFreeMarkException;
import up.jerboa.util.serialization.JerboaSerializeException;
import up.jerboa.util.serialization.jba.JBAEmbeddingSerialization;
import up.jerboa.util.serialization.jba.JBAFormat;

import $$MODELER_PACKAGE.$$MODELER_NAME;

// Embeddings includes
$$EBD_INCLUDE
//////////////////////

public class $$BRIDGE_NAME implements GMapViewerBridge, JerboaGMapDuplicateFactory {

	$$MODELER_NAME modeler;

	private JBAEmbeddingSerialization factory;

	private GMapViewer viewer;

	public $$BRIDGE_NAME() {
		super();

		 // TODO Auto-generated constructor stub
	}

	public $$BRIDGE_NAME($$MODELER_NAME modeler) {
		this.modeler = modeler;
		 //this.modeler.setBridge(this);

		factory = new $$SERIALIZER_TYPE(modeler);
		viewer = null;
	}


	public Camera getCamera() {
		if(viewer!=null) return viewer.getCamera(); 
		return null; 
	}


	public GMapViewer getViewer() {
		return viewer;
	}

	public void setViewer(GMapViewer viewer) {
		this.viewer = viewer;
	}

	@Override
	public boolean hasColor() {
		return true;
	}

	@Override
	public boolean hasNormal() {
		return false;
	}

	@Override
	public GMapViewerPoint coords(JerboaDart n) {
		try {
			$$EBD_PRESET_POSITION_TYPE p = n.<$$EBD_PRESET_POSITION_TYPE>ebd($$EBD_PRESET_POSITION_ID);
			GMapViewerPoint res = new GMapViewerPoint((float) p.getX(), (float) p.getY(), (float) p.getZ());
			return res;
		} catch (NullPointerException e) {
			System.err.println("Error in node " + n.getID());
			throw e;
		}
	}

	@Override
	public GMapViewerColor colors(JerboaDart n) {

		$$EBD_PRESET_COLOR_TYPE c = n.ebd($$EBD_PRESET_COLOR_ID);
		GMapViewerColor res = new GMapViewerColor(c.getR(), c.getG(), c.getB(), c.getA());
		return res;
	}


	@Override
	public GMapViewerTuple normals(JerboaDart n) {
		JerboaGMap gmap = modeler.getGMap();
		$$EBD_PRESET_POSITION_TYPE normal = null;
		 if(($$EBD_PRESET_ORIENT_TYPE) (n.ebd($$EBD_PRESET_ORIENT_ID))!=null){ // pour modèle chargé, on test juste si le plongement existe
		 	JerboaDart tmp = n;
		 	if(getOrient(n)){
		 		tmp = tmp.alpha(1);
		 	}
		 	$$EBD_PRESET_POSITION_TYPE p0 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp));
		 	$$EBD_PRESET_POSITION_TYPE p1 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp.alpha(0))); 
		 	$$EBD_PRESET_POSITION_TYPE p2 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp.alpha(1).alpha(0)));
		 	normal = p1.subConst(p0).cross(p2.subConst(p0));
		 	normal.normalize();
		 	if(normal.norm()>=0.1) {
		 		return new GMapViewerTuple((float)normal.getX(), (float)normal.getY(), (float)normal.getZ());
		 	}

			 // If not worked
		 	int markview;
		 	try {
		 		markview = gmap.getFreeMarker();
		 	} catch (JerboaNoFreeMarkException e) {
		 		e.printStackTrace();
		 		return null;
		 	}
		 	while(tmp.isNotMarked(markview)){
		 		gmap.mark(markview, tmp);
		 		p0 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp));
		 		p1 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp.alpha(0))); 
		 		p2 = new $$EBD_PRESET_POSITION_TYPE(coords(tmp.alpha(1).alpha(0)));
		 		normal = p1.subConst(p0).cross(p2.subConst(p0));
		 		if(normal.norm()>=0.1) {
		 			normal = p1.subConst(p0).cross(p2.subConst(p0));
		 			normal.normalize();
		 		}
		 		tmp = tmp.alpha(0).alpha(1);
		 	}
		 	gmap.freeMarker(markview);
		 }
		 return new GMapViewerTuple((float)normal.getX(), (float)normal.getY(), (float)normal.getZ());
		}

		@Override
		public void load(GMapViewer view, JerboaMonitorInfo worker) {
			JFileChooser filec = new JFileChooser();
			FileFilter jbafilter = new FileNameExtensionFilter("JBA format (*.jba)", "jba");
			FileFilter epcfilter = new FileNameExtensionFilter("EPC format (*.epc)", "epc");
			FileFilter jbaepcfilter = new FileNameExtensionFilter("EPC & JBA formats (*.epc;*.jba)", "epc","jba");

			filec.addChoosableFileFilter(jbafilter);
			filec.addChoosableFileFilter(epcfilter);
			filec.addChoosableFileFilter(jbaepcfilter);

			filec.setFileFilter(jbaepcfilter);

			if (filec.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {
				load(filec.getSelectedFile(), worker);
				try {
					loadExtra(new FileInputStream(filec.getSelectedFile()));
				} catch (FileNotFoundException e) {
					e.printStackTrace();
				}
			}
		}

		public void load(File file, JerboaMonitorInfo worker) {
			try {
				if(file.getName().endsWith(".jba")) {			
					JBAFormat formatjba = new JBAFormat(modeler, new JerboaMonitorInfoBridgeSerializerMonitor(worker), factory);
					FileInputStream fos = new FileInputStream(file);
					formatjba.load(fos);
				}
			} catch (IOException | JerboaSerializeException | JerboaException e) {
				e.printStackTrace();
			}
			finally {
				$$MODELER_NAMELauncher.current.updateIHM();
			}

		}

		@Override
		public void save(GMapViewer view, JerboaMonitorInfo worker) {
			JFileChooser filec = new JFileChooser();
			FileFilter jbafilter = new FileNameExtensionFilter("JBA format (*.jba)", "jba");
			FileFilter allfilter = new FileNameExtensionFilter("All files (*.*)", "*");

			filec.addChoosableFileFilter(jbafilter);
			filec.addChoosableFileFilter(allfilter);
			filec.setFileFilter(jbafilter);

			if (filec.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {
				System.err.println("Selected file to save in : " + filec.getSelectedFile().getAbsolutePath());
				FileOutputStream fos;
				try {
					fos = new FileOutputStream(filec.getSelectedFile());
					if (filec.getFileFilter() == jbafilter) {
					 /*
					 try {
						 ArrayList<ArrayList<JerboaDart>> pillars = new ArrayList<>();
						 for(ArrayList<Integer> pil : listOfAllCorrespondingDartAsPillars) {
							 ArrayList<JerboaDart> piDarts = new ArrayList<>();
							 for(Integer pi: pil) {
								 piDarts.add(modeler.getGMap().node(pi));
							 }
							 pillars.add(piDarts);
						 }
						 JBAFormat formatjba = new JBAFormat(modeler,
								 new JerboaMonitorInfoBridgeSerializerMonitor(worker), factory);

						 formatjba.save(fos);
						 saveExtraData(fos, pillars);
					 } catch (JerboaSerializeException e) {
						 e.printStackTrace();
					 } catch (JerboaException e) {
						 e.printStackTrace();
					 }
					 */
				 }else {// if(filec.getSelectedFile().getPath().endsWith(".epc")) {
				 	System.err.println("Trying to save EPC at path : " + filec.getSelectedFile().getPath());
					 //epcmanager.saveEPC( filec.getSelectedFile());//filec.getSelectedFile().getPath() );
				 	System.err.println("end save : " + filec.getSelectedFile().getPath());
				 }

				} catch (Exception e) {
					e.printStackTrace();
				}

			}

		}



		@Override
		public boolean canUndo() {
			return true;
		}

		@Override
		public JerboaGMap duplicate(JerboaGMap gmap) throws JerboaGMapDuplicateException {
			JerboaGMap res = new JerboaGMapArray(modeler,gmap.getCapacity());
			gmap.duplicateInGMap(res, this);
			return res;
		}

		@Override
		public List<Pair<String, String>> getCommandLineHelper() {
			ArrayList<Pair<String,String>> help = new ArrayList<>();
/*		 help.add(new Pair<String,String>("timelaps [TRUE | FALSE]","enable or disable timelaps during meshing."));
		 help.add(new Pair<String, String>("fold", "swap display to FoldPoint (alias foldPoint, aplat, posAplat)"));
		 help.add(new Pair<String, String>("flat", "swap display to FlatPoint (alias flatPoint, plie, posPlie)"));
		 help.add(new Pair<String, String>("orient", "check orientation property"));
		 help.add(new Pair<String, String>("relations", "display all relationships inside the EPC"));

		 help.add(new Pair<String,String>("normal [DARTID]","print the dart normal"));
*/
		 return help;
		}

		@Override
		public boolean parseCommandLine(PrintStream ps, String line) {
			StringTokenizer tok = new StringTokenizer(line);
			switch(tok.nextToken().toLowerCase()) {
				case "normal": {
					String dartId = tok.nextToken();
					if(dartId.length()>0) {
						try {
							System.err.println(" normal :  " + normals(modeler.getGMap().node(Integer.parseInt(dartId))));
						}catch(Exception e) {return false;}
					}
					return true;
				}
		 /*
		case "timelaps": 
			String enable = tok.nextToken();
			if(enable.length()>0) {
				if(enable.compareToIgnoreCase("true")==0 || enable.compareToIgnoreCase("on")==0 ) {
					modeler.TIMELAPS = true;
				}else if(enable.compareToIgnoreCase("false")==0 || enable.compareToIgnoreCase("off")==0 ){
					modeler.TIMELAPS = false;
				}
				System.out.println("Timelapse is " + (modeler.TIMELAPS?"on":"off"));
			}
			return true;
		 case "aplat":
		 case "posaplat":
		 case "flat":
		 case "flatpoint":{
			 displayFold = false;
			 $$MODELER_NAMELauncher.current.updateIHM();
			 return true;
		 }
		 case "plie":
		 case "posplie":
		 case "fold": 
		 case "foldpoint": {
			 displayFold = true;
			 $$MODELER_NAMELauncher.current.updateIHM();
			 return true;
			}*/
			case "orient": {
				int errors = 0;
				for (JerboaDart d : modeler.getGMap()) {
					for(int i = 0;i <= 3; i++) {
						if(!d.isFree(i)) {
							if(d.alpha(i).ebd($$EBD_PRESET_ORIENT_ID) == d.ebd($$EBD_PRESET_ORIENT_ID) ) {
								System.err.println("OUPS: orientation problem between: "+d.getID()+" ---"+i+"--- "+d.alpha(i).getID());
								errors++;
							}
					 } // end if
					}   
				}
				System.err.println("ORIENTATION ERRORS: "+(errors/2));

				return true;
			}
		}
		return false;
	}

	@Override
	public boolean hasOrient() {
	 	// TODO: replace value if the modeler has not orientation
		return true;
	}

	@Override
	public boolean getOrient(JerboaDart n) {
		return n.<$$EBD_PRESET_ORIENT_TYPE> ebd($$EBD_PRESET_ORIENT_ID);
	}


	@Override
	public Object duplicate(JerboaEmbeddingInfo info, Object value) {
		 // TODO: do your own copy
		return value;
	}

	@Override
	public JerboaEmbeddingInfo convert(JerboaEmbeddingInfo info) {
		 // TODO: replace by your own code
		return info;
	}

	@Override
	public boolean manageEmbedding(JerboaEmbeddingInfo info) {
		 // TODO: replace by your own code
		return true;
	}

	@Override
	public JerboaModeler getModeler() {
		return modeler;
	}

	@Override
	public JerboaGMap getGMap() {
		return modeler.getGMap();
	}

	public void saveExtraData(FileOutputStream fos, ArrayList<ArrayList<JerboaDart>> pillars) {
		 // TODO: fill with your own code to add additional information to jba files
	}

	public void loadExtra(FileInputStream in) {
		 // TODO: fill with your own code to read additional information from jba files
	}


}
